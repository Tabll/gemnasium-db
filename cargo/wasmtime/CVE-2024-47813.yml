---
identifier: "CVE-2024-47813"
identifiers:
- "CVE-2024-47813"
- "GHSA-7qmx-3fpx-r45m"
package_slug: "cargo/wasmtime"
title: "Wasmtime race condition could lead to WebAssembly control-flow integrity and
  type safety violations"
description: "Under certain concurrent event orderings, a `wasmtime::Engine`'s internal
  type registry was susceptible to double-unregistration bugs due to a race condition,
  leading to panics and potentially type registry corruption. That registry corruption
  could, following an additional and particular sequence of concurrent events, lead
  to violations of WebAssembly's control-flow integrity (CFI) and type safety. Users
  that do not use `wasmtime::Engine` across multiple threads are not affected. Users
  that only create new modules across threads over time are additionally not affected.\n\nReproducing
  this bug requires creating and dropping multiple type instances (such as `wasmtime::FuncType`
  or `wasmtime::ArrayType`) concurrently on multiple threads, where all types are
  associated with the same `wasmtime::Engine`. **Wasm guests cannot trigger this bug.**
  See the \"References\" section below for a list of Wasmtime types-related APIs that
  are affected.\n\nWasmtime maintains an internal registry of types within a `wasmtime::Engine`
  and an engine is shareable across threads. Types can be created and referenced through
  creation of a `wasmtime::Module`, creation of `wasmtime::FuncType`, or a number
  of other APIs where the host creates a function (see \"References\" below). Each
  of these cases interacts with an engine to deduplicate type information and manage
  type indices that are used to implement type checks in WebAssembly's `call_indirect`
  function, for example. This bug is a race condition in this management where the
  internal type registry could be corrupted to trigger an assert or contain invalid
  state.\n\nWasmtime's internal representation of a type has individual types (e.g.
  one-per-host-function) maintain a registration count of how many time it's been
  used. Types additionally have state within an engine behind a read-write lock such
  as lookup/deduplication information. The race here is a time-of-check versus time-of-use
  (TOCTOU) bug where one thread atomically decrements a type entry's registration
  count, observes zero registrations, and then acquires a lock in order to unregister
  that entry. However, between when this first thread observed the zero-registration
  count and when it acquires that lock, another thread could perform the following
  sequence of events: re-register another copy of the type, which deduplicates to
  that same entry, resurrecting it and incrementing its registration count; then drop
  the type and decrement its registration count; observe that the registration count
  is now zero; acquire the type registry lock; and finally unregister the type. Now,
  when the original thread finally acquires the lock and unregisters the entry, it
  is the second time this entry has been unregistered.\n\n| Thread A                          |
  Thread B                       |\n|-----------------------------------|--------------------------------|\n|
  `acquire(type registry lock)`     |                                |\n|                                   |
  `decref(E) --> 0`              |\n|                                   | `block_on(type
  registry lock)` |\n| `register(E') == incref(E) --> 1` |                                |\n|
  `release(type registry lock)`     |                                |\n| `decref(E)
  --> 0`                 |                                |\n| `acquire(type registry
  lock)`     |                                |\n| `unregister(E)`                   |
  \                               |\n| `release(type registry lock)`     |                                |\n|
  \                                  | `acquire(type registry lock)`  |\n|                                   |
  `unregister(E)`          |\n\n\nThis double-unregistration could then lead to a
  WebAssembly CFI violation under the following conditions: a new WebAssembly module
  `X` was loaded into the engine before the second, buggy unregistration occurs; `X`
  defined a function type `F` that was allocated in the same type registry slot where
  the original entry was allocated; the second, buggy unregistration incorrectly unregistered
  `F`; another new WebAssembly module `Y` was loaded into the engine; `Y` defined
  a function type `G`, different from `F`, but which is also allocated in the same
  type registry slot; a `funcref` of type `G` is created, either by the host or by
  Wasm; that `funcref` is passed to a WebAssembly instance of module `X`; that instance
  performs a `call_indirect` to that `funcref`; the `call_indirect`'s dynamic type
  check, which preserves CFI, could incorrectly pass in this case, because `F` and
  `G` were assigned the same type registry slot. This would, ultimately, allow calling
  a function with too many, too few, or wrongly-typed arguments, violating CFI and
  type safety.\n\nWe were not able to reproduce this CFI violation in a vanilla Wasmtime
  build, although it remains theoretically possible. However, by modifying Wasmtime's
  source code to make losing the races described above more likely (by disabling certain
  assertions, inserting panic catches, and adding retry loops in a few places if we
  did *not* lose the race) we were able to incorrectly get a `funcref` to pass a type
  check that it should have failed, which would allow the CFI violation."
date: "2024-10-09"
pubdate: "2024-10-09"
affected_range: ">=19.0.0 <21.0.2||>=22.0.0 <22.0.1||>=23.0.0 <23.0.3||>=24.0.0 <24.0.1||>=25.0.0
  <25.0.2"
fixed_versions:
- "21.0.2"
- "22.0.1"
- "23.0.3"
- "24.0.1"
- "25.0.2"
affected_versions: "All versions starting from 19.0.0 before 21.0.2, all versions
  starting from 22.0.0 before 22.0.1, all versions starting from 23.0.0 before 23.0.3,
  all versions starting from 24.0.0 before 24.0.1, all versions starting from 25.0.0
  before 25.0.2"
not_impacted: "All versions before 19.0.0, all versions starting from 21.0.2 before
  22.0.0, all versions starting from 22.0.1 before 23.0.0, all versions starting from
  23.0.3 before 24.0.0, all versions starting from 24.0.1 before 25.0.0, all versions
  starting from 25.0.2"
solution: "Upgrade to versions 21.0.2, 22.0.1, 23.0.3, 24.0.1, 25.0.2 or above."
urls:
- "https://nvd.nist.gov/vuln/detail/CVE-2024-47813"
- "https://github.com/advisories/GHSA-7qmx-3fpx-r45m"
- "https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-7qmx-3fpx-r45m"
- "https://github.com/bytecodealliance/wasmtime/pull/7969"
- "https://github.com/bytecodealliance/wasmtime/commit/0ebe54d05f0e1f6c64b7c8bb48c9e9f6c95cacba"
- "https://github.com/bytecodealliance/wasmtime"
cvss_v3: "CVSS:3.1/AV:L/AC:H/PR:H/UI:R/S:U/C:N/I:L/A:L"
uuid: "b6c9f532-4d4f-4f16-b15e-4e48513160d7"
cwe_ids:
- "CWE-367"
- "CWE-937"
- "CWE-1035"
