---
identifier: "CVE-2023-26489"
identifiers:
- "CVE-2023-26489"
- "GHSA-ff4p-7xrq-q5r8"
package_slug: "cargo/cranelift-codegen"
title: "wasmtime vulnerable to guest-controlled out-of-bounds read/write on x86_64"
description: "Wasmtime's code generator, Cranelift, has a bug on x86_64 targets where
  address-mode computation mistakenly would calculate a 35-bit effective address instead
  of WebAssembly's defined 33-bit effective address. This bug means that, with default
  codegen settings, a wasm-controlled load/store operation could read/write addresses
  up to 35 bits away from the base of linear memory. Wasmtime's default sandbox settings
  provide up to 6G of protection from the base of linear memory to guarantee that
  any memory access in that range will be semantically correct. Due to this bug, however,
  addresses up to `0xffffffff * 8 + 0x7ffffffc = 36507222004 = ~34G` bytes away from
  the base of linear memory are possible from guest code. This means that the virtual
  memory 6G away from the base of linear memory up to ~34G away can be read/written
  by a malicious module.\n\nThis out of bounds read/write is not semantically correct
  and poses a threat as an arbitrary read/write within ~34G of linear memory away
  from the base of a wasm module's linear memory. A guest module can, without the
  knowledge of the embedder, read/write memory in this region. The memory may belong
  to other WebAssembly instances when using the pooling allocator, for example. The
  memory may also belong to the embedder, depending on address layout.\n\nEmbedders
  do not have a necessarily reliable means of detecting when this happens. Wasm loads/stores
  are allowed to cause machine segfaults meaning that an invalid read/write would
  be translated to a nominal WebAssembly trap. This means that a malicious module
  in the worst case silently reads/writes memory outside its bounds and in the \"best\"
  case looks like a normal \"something trapped here\" during its execution. This makes
  it difficult to retroactively determine whether this bug has been exploited on hosts.
  Affected embedders are recommended to analyze preexisting wasm modules to see if
  they're affected by the incorrect codegen rules and possibly correlate that with
  an anomalous number of traps during historical execution to locate possibly suspicious
  modules.\n\nThe specific bug in Cranelift's x86_64 backend is that a WebAssembly
  address which is left-shifted by a constant amount from 1 to 3 will get folded into
  x86_64's addressing modes which perform shifts. For example `(i32.load (i32.shl
  (local.get 0) (i32.const 3)))` loads from the WebAssembly address `$local0 << 3`.
  When translated to Cranelift the `$local0 << 3` computation, a 32-bit value, is
  zero-extended to a 64-bit value and then added to the base address of linear memory.
  Cranelift would generate an instruction of the form `movl (%base, %local0, 8), %dst`
  which calculates `%base + %local0 << 3`. The bug here, however, is that the address
  computation happens with 64-bit values, where the `$local0 << 3` computation was
  supposed to be truncated to a 32-bit value. This means that `%local0`, which can
  use up to 32-bits for an address, gets 3 extra bits of address space to be accessible
  via this `movl` instruction.\n\nThe fix in Cranelift is to remove the erroneous
  lowering rules in the backend which handle these zero-extended expressions. The
  above example is then translated to `movl %local0, %temp; shl $3, %temp; movl (%base,
  %temp), %dst` which correctly truncates the intermediate computation of `%local0
  << 3` to 32-bits inside the `%temp` register which is then added to the `%base`
  value."
date: "2023-03-09"
pubdate: "2023-03-09"
affected_range: ">=0.84.0 <0.91.1||>=0.92.0 <0.92.1||>=0.93.0 <0.93.1"
fixed_versions:
- "0.91.1"
- "0.92.1"
- "0.93.1"
affected_versions: "All versions starting from 0.84.0 before 0.91.1, all versions
  starting from 0.92.0 before 0.92.1, all versions starting from 0.93.0 before 0.93.1"
not_impacted: "All versions before 0.84.0, all versions starting from 0.91.1 before
  0.92.0, all versions starting from 0.92.1 before 0.93.0, all versions starting from
  0.93.1"
solution: "Upgrade to versions 0.91.1, 0.92.1, 0.93.1 or above."
urls:
- "https://nvd.nist.gov/vuln/detail/CVE-2023-26489"
- "https://github.com/advisories/GHSA-ff4p-7xrq-q5r8"
- "https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-ff4p-7xrq-q5r8"
- "https://github.com/bytecodealliance/wasmtime/commit/63fb30e4b4415455d47b3da5a19d79c12f4f2d1f"
- "https://docs.rs/wasmtime/latest/wasmtime/struct.Config.html#method.static_memory_guard_size"
- "https://docs.rs/wasmtime/latest/wasmtime/struct.Config.html#method.static_memory_maximum_size"
- "https://github.com/bytecodealliance/wasmtime"
- "https://groups.google.com/a/bytecodealliance.org/g/sec-announce/c/Mov-ItrNJsQ"
cvss_v3: "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:H/I:H/A:H"
uuid: "a887a014-eedb-4b1c-93db-bd4c9acf20e0"
cwe_ids:
- "CWE-125"
- "CWE-787"
- "CWE-937"
- "CWE-1035"
